package net.technearts.proxy;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.IOException;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;public class Session extends Thread {  enum Status {    SC_OK, SC_CONNECTING_TO_HOST, SC_HOST_NOT_FOUND, SC_CLIENT_ERROR,    SC_INTERNAL_SERVER_ERROR, SC_NOT_SUPPORTED, SC_CONNECTION_CLOSED,    SC_HTTP_OPTIONS_THIS, SC_MOVED_PERMANENTLY;  }  private static Server server;  private static final Logger LOG = LogManager.getLogger();  /** downstream connections */  private Socket client;  private BufferedOutputStream out;  private ClientInputStream in;  /** upstream connections */  private Socket HTTP_Socket;  private BufferedOutputStream HTTP_out;  private BufferedInputStream HTTP_in;  public Session(final Server server, final Socket client) {    try {      in = new ClientInputStream(server, this, client.getInputStream());      out = new BufferedOutputStream(client.getOutputStream());      Session.server = server;      this.client = client;    } catch (final IOException e_io) {      try {        client.close();      } catch (final IOException e_io2) {}      LOG.error("Error while creating IO-Streams: " + e_io);      return;    }    start();  }  /** connects to the given host and port */  private void connect(final InetAddress host, final int port)      throws IOException {    HTTP_Socket = new Socket(host, port);    HTTP_in = new BufferedInputStream(HTTP_Socket.getInputStream());    HTTP_out = new BufferedOutputStream(HTTP_Socket.getOutputStream());  }  private void endHeader() throws IOException {    write(out, "\r\n");  }  public Socket getLocalSocket() {    return client;  }  /*   * public Socket getRemoteSocket() { return HTTP_Socket; }   */  public Status getStatus() {    return in.getStatusCode();  }  /** the main routine, where it all happens */  private void handleRequest() throws Exception {    InetAddress remote_host;    Reader remote_in = null;    int remote_port;    final byte[] b = new byte[65536];    int numread = in.read(b);    while (true) { // with this loop we support persistent connections      if (numread == -1) { // -1 signals an error        if (!in.getStatusCode().equals(Status.SC_CONNECTING_TO_HOST)) {          switch (in.getStatusCode()) {          case SC_CONNECTION_CLOSED:            break;          case SC_CLIENT_ERROR:            sendErrorMSG(400,                "Your client sent a request that this proxy could not understand. ("                    + in.getErrorDescription() + ")");            break;          case SC_HOST_NOT_FOUND:            sendErrorMSG(504,                "Host not found.<BR>jHTTPp2 was unable to resolve the hostname of this request. <BR>Perhaps the hostname was misspelled, the server is down or you have no connection to the internet.");            break;          case SC_INTERNAL_SERVER_ERROR:            sendErrorMSG(500,                "Server Error! (" + in.getErrorDescription() + ")");            break;          case SC_NOT_SUPPORTED:            sendErrorMSG(501,                "Your client used a HTTP method that this proxy doesn't support: ("                    + in.getErrorDescription() + ")");            break;          case SC_HTTP_OPTIONS_THIS:            sendHeader(200);            endHeader();            break;          case SC_MOVED_PERMANENTLY:            sendHeader(301);            write(out, "Location: " + in.getErrorDescription() + "\r\n");            endHeader();            out.flush();          default:          }          break; // return from main loop.        } else {          /*           * also an error because we are not connected (or to the wrong host)           */          // Creates a new connection to a remote host.          if (!notConnected()) {            try {              HTTP_Socket.close();            } catch (final IOException e_close_socket) {}          }          // get the header length          numread = in.getHeaderLength();          if (!server.isUseProxy()) {            // sets up hostname and port            remote_host = in.getRemoteHost();            remote_port = in.getRemotePort();          } else {            remote_host = server.getProxy();            remote_port = server.getProxyPort();          }          if (server.isDebug()) {            LOG.info("Connect: " + remote_host + ":" + remote_port);          }          try {            connect(remote_host, remote_port);          } catch (final IOException e_connect) {            if (server.isDebug()) {              LOG.debug(e_connect.toString());            }            sendErrorMSG(502, "Error while creating a TCP connecting to ["                + remote_host.getHostName() + ":" + remote_port                + "] <BR>The proxy server cannot connect to the given address or port ["                + e_connect.toString() + "]");            break;          } catch (final Exception e) {            LOG.error(e.toString());            sendErrorMSG(500, "Error: " + e.toString());            break;          }          if (!in.isSSL() || in.isSSL() && server.isUseProxy()) {            /*             * no SSL-Tunnel or SSL-Tunnel with another remote proxy: simply             * forward the request             */            HTTP_out.write(b, 0, numread);            HTTP_out.flush();          } else {            /*             * SSL-Tunnel with "CONNECT": creates a tunnel connection with the             * server             */            sendLine(server.getHttpVersion() + " 200 Connection established");            sendLine("Proxy-Agent", server.getServerIdentification());            endHeader();            out.flush();          }          // reads data from the remote server          remote_in = new Reader(this, HTTP_in, out);        }      }      while (true) {        // reads data from the client        numread = in.read(b);        if (server.isDebug()) {          LOG.debug("Session: " + numread + " Bytes // read.");        }        if (numread != -1) {          HTTP_out.write(b, 0, numread);          HTTP_out.flush();        } else {          break;        }      } // end of inner loop    } // end of main loop    out.flush();    if (!notConnected() && remote_in != null) {      remote_in.close(); // close Reader thread    }    return;  }  /*   * public boolean isTunnel() { return in.isTunnel(); }   */  public boolean notConnected() {    return HTTP_Socket == null;  }  @Override  public void run() {    if (server.isDebug()) {      LOG.debug("begin http session");    }    try {      handleRequest();    } catch (final IOException e_handleRequest) {      if (server.isDebug()) {        LOG.debug(e_handleRequest.toString());      }    } catch (final Exception e) {      e.printStackTrace();      LOG.error("Session.run(); " + e.getMessage());    } finally {      try {        // close downstream connections        in.close(); // since 0.4.10b        out.close();        client.close();        // close upstream connections (webserver or other proxy)        if (!notConnected()) {          HTTP_Socket.close();          HTTP_out.close();          HTTP_in.close();        }      } catch (final IOException e_run) {        LOG.error(e_run.getMessage());      }      if (server.isDebug()) {        LOG.debug("end http session");      }    }  }  /** sends a message to the user */  private void sendErrorMSG(final int a, final String info) throws IOException {    final String statuscode = sendHeader(a);    String localhost = "localhost";    try {      localhost = InetAddress.getLocalHost().getHostName() + ":"          + server.getPort();    } catch (final UnknownHostException e_unknown_host) {}    final String msg = String.format(        "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">"            + "<HTML>\r<!-- JProxy error message --><HEAD>\r<TITLE>%s</TITLE>\r"            + "<link rel=\"stylesheet\" type=\"text/css\" href=\"http://%s/style.css\"></HEAD>\r"            + "<BODY BGCOLOR=\"#FFFFFF\" TEXT=\"#000000\" LINK=\"#000080\" VLINK=\"#000080\" ALINK=\"#000080\">\r"            + "<h2 class=\"headline\">HTTP %s </h2>\r<HR size=\"4\">\r"            + "<p class=\"i30\">Your request for the following URL failed:</p>"            + "<p class=\"tiagtext\"><a href=\"%s\">%s</A> </p>\r<P class=\"i25\">Reason: %s</P><HR size=\"4\">\r"            + "<p class=\"i25\"><A HREF=\"http://jhttp2.sourceforge.net/\">jHTTPp2</A></p>\r"            + "</BODY></HTML>",        statuscode, localhost, statuscode, in.getFullURL(), in.getFullURL(),        info, server.getServerVersion(), localhost);    sendLine("Content-Length", String.valueOf(msg.length()));    sendLine("Content-Type", "text/html; charset=iso-8859-1");    endHeader();    write(out, msg);    out.flush();  }  private String sendHeader(final int a) throws IOException {    String stat;    switch (a) {    case 200:      stat = "200 OK";      break;    case 202:      stat = "202 Accepted";      break;    case 300:      stat = "300 Ambiguous";      break;    case 301:      stat = "301 Moved Permanently";      break;    case 400:      stat = "400 Bad Request";      break;    case 401:      stat = "401 Denied";      break;    case 403:      stat = "403 Forbidden";      break;    case 404:      stat = "404 Not Found";      break;    case 405:      stat = "405 Bad Method";      break;    case 413:      stat = "413 Request Entity Too Large";      break;    case 415:      stat = "415 Unsupported Media";      break;    case 501:      stat = "501 Not Implemented";      break;    case 502:      stat = "502 Bad Gateway";      break;    case 504:      stat = "504 Gateway Timeout";      break;    case 505:      stat = "505 HTTP Version Not Supported";      break;    default:      stat = "500 Internal Server Error";    }    sendLine(server.getHttpVersion() + " " + stat);    sendLine("Server", server.getServerIdentification());    if (a == 501) {      sendLine("Allow", "GET, HEAD, POST, PUT, DELETE, CONNECT");    }    sendLine("Cache-Control", "no-cache, must-revalidate");    sendLine("Connection", "close");    return stat;  }  private void sendLine(final String s) throws IOException {    write(out, s + "\r\n");  }  private void sendLine(final String header, final String s)      throws IOException {    write(out, header + ": " + s + "\r\n");  }  /** converts an String into a Byte-Array to write it with the OutputStream */  private void write(final BufferedOutputStream o, final String p)      throws IOException {    o.write(p.getBytes(), 0, p.length());  }}